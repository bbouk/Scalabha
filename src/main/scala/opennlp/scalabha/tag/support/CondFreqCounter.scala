package opennlp.scalabha.tag.support

import opennlp.scalabha.util.CollectionUtils._
import opennlp.scalabha.util.Pattern
import opennlp.scalabha.util.Probability
import opennlp.scalabha.util.Probability._
import org.apache.commons.logging.LogFactory

/**
 * A builder for conditional frequency distributions.  Stores counts (in a mutable
 * fashion) and allows counts to be added.  A distribution based on the
 * counts is generated by calling 'toFreqDist'.
 *
 * This is the top of a hierarchy designed for a modular approach to
 * frequency distribution building.  SimpleCondFreqCounter serves as the basic
 * form of the counter; it stores and increments the actual counts.  Other
 * implementations of CondFreqCounter will be count-transforming decorators
 * extending DelegatingCondFreqCounter that wrap SimpleCondFreqCounter or wrap
 * wrappers thereof.  Multiple layers of decoration allow various
 * transformations to be applied to the counts, and in varying orders.
 *
 * The operation of the system is such that counts, when added via the
 * top-most layer are passed, untouched, all the way to the base where they
 * are stored.  When toFreqDist is called, the counts are gathered via
 * recursive calls to resultCounts that travel down the layers to the bottom,
 * where the true counts are retrieved.  Each layer, starting from the bottom,
 * then applies its transformation and returns the modified counts to be
 * received by the higher layers.  Once the (modified) counts reach the top,
 * they are used to calculate the distribution.
 *
 * For example, the following code will create a CondFreqCounter that, before
 * creating a distribution, will constrain its counts to those in validEntries
 * and then smooth the constrained counts:
 * {{{
 *   new SimpleSmoothingCondFreqCounter(lambda,
 *     new ConstrainingCondFreqCounter(validEntries, strict,
 *       new SimpleCondFreqCounter()))
 * {{{
 *
 * Implementing classes should define:
 * <ul>
 *   <li> increment: Add to counts. Should simply forward to delegate.
 *   <li> resultCounts: Apply transformation to delegate's resultCounts.
 * </ul>
 *
 * @tparam A	the conditioning item being counted; P(B|A).
 * @tparam B	the conditioned item being counted; P(B|A).
 */
abstract class CondFreqCounter[A, B] {
  def increment(a: A, b: B, n: Double)
  def resultCounts(): DefaultedCondFreqCounts[A, B, Double]

  final def ++=[N](other: CondFreqCounts[A, B, N])(implicit num: Numeric[N]): CondFreqCounter[A, B] = { other.iterator.foreach { case (a, bs) => bs.iterator.foreach { case (b, n) => increment(a, b, num.toDouble(n)) } }; this }
  final def ++=(other: CondFreqCounter[A, B]): CondFreqCounter[A, B] = this ++= new CondFreqCounts(other.resultCounts.counts.mapValuesStrict(_.counts))

  final def toFreqDist: A => B => Probability = {
    CondFreqDist(resultCounts())
  }
}

//////////////////////////////////////
// Base Implementation
//////////////////////////////////////

/**
 * The base CondFreqCounter implementation that directly stores and updates a
 * (mutable) map of counts.
 */
class SimpleCondFreqCounter[A, B] extends CondFreqCounter[A, B] {
  private val storedCounts = collection.mutable.Map[A, FreqCounter[B]]()
  override def increment(a: A, b: B, n: Double) { storedCounts.getOrElseUpdate(a, new SimpleFreqCounter[B]).increment(b, n) }
  override def resultCounts() = DefaultedCondFreqCounts(storedCounts.toMap.mapValuesStrict(_.resultCounts), 0, 0)
  override def toString = storedCounts.mapValues(_.toString).toString
}

//////////////////////////////////////
// Delegating Implementation
//////////////////////////////////////

/**
 * The base CondFreqCounter decorator.  It handles the counter incrementing,
 * so subclasses need only implement resultCounts.
 *
 * @param delegate	the delegate counter upon which the transformation is performed
 */
abstract class DelegatingCondFreqCounter[A, B](delegate: CondFreqCounter[A, B]) extends CondFreqCounter[A, B] {
  final override def increment(a: A, b: B, n: Double) { delegate.increment(a, b, n) }
}

//////////////////////////////////////
// Constraining Implementation
//////////////////////////////////////

/**
 * CondFreqCounter decorator that zero out counts for entries not found in
 * validEntries.
 *
 * @param validEntries	zero out entries not found in this set
 * @param delegate	the delegate counter upon which the transformation is performed
 */
class ConstrainingCondFreqCounter[A, B](validEntries: Map[A, Set[B]], delegate: CondFreqCounter[A, B]) extends DelegatingCondFreqCounter[A, B](delegate) {
  override def resultCounts() = {
    val DefaultedCondFreqCounts(delegateResultCounts, delegateTotalAddition, delegateDefaultCount) = delegate.resultCounts()
    val filteredResultCounts =
      validEntries.map {
        case (a, bs) =>
          delegateResultCounts.get(a) match {
            case Some(DefaultedFreqCounts(aCounts, aTotalAdd, aDefault)) =>
              val filtered = FreqCounts(aCounts.toMap.filterKeys(bs))
              val defaults = FreqCounts((bs -- aCounts.toMap.keySet).mapTo(b => aDefault).toMap)
              (a, DefaultedFreqCounts(filtered ++ defaults, 0.0, 0.0))
            case None =>
              val defaults = FreqCounts(bs.mapTo(b => delegateDefaultCount).toMap)
              (a, DefaultedFreqCounts(defaults, 0.0, 0.0))
          }
      }
    DefaultedCondFreqCounts(filteredResultCounts, 0.0, 0.0)
  }
}

object ConstrainingCondFreqCounter {
  def apply[A, B](validEntries: Map[A, Set[B]], delegate: CondFreqCounter[A, B]) =
    new ConstrainingCondFreqCounter(validEntries, delegate)

  def apply[A, B](validEntries: Option[Map[A, Set[B]]], delegate: CondFreqCounter[A, B]) =
    validEntries match {
      case Some(validEntries) => new ConstrainingCondFreqCounter(validEntries, delegate)
      case None => delegate
    }
}

//////////////////////////////////////
// Scaling Implementation
//////////////////////////////////////

/**
 * CondFreqCounter decorator that multiplies every count by some lambda
 *
 * @param lambda	the amount to scale each count
 * @param delegate	the delegate counter upon which the transformation is performed
 */
class ScalingCondFreqCounter[A, B](lambda: Double, delegate: CondFreqCounter[A, B]) extends DelegatingCondFreqCounter[A, B](delegate) {
  override def resultCounts() = {
    val DefaultedCondFreqCounts(delegateResultCounts, delegateTotalAddition, delegateDefaultCount) = delegate.resultCounts
    val filteredResultCounts =
      for ((a, DefaultedFreqCounts(aCounts, aTotalAdd, aDefault)) <- delegateResultCounts) yield {
        val scaled = FreqCounts(aCounts.toMap.mapValuesStrict(_ * lambda))
        (a, DefaultedFreqCounts(scaled, aTotalAdd * lambda, aDefault * lambda))
      }
    DefaultedCondFreqCounts(filteredResultCounts, delegateTotalAddition * lambda, delegateDefaultCount * lambda)
  }
}

//////////////////////////////////////
// Add-lambda smoothing implementation
//////////////////////////////////////

/**
 * Basic add-lambda smoothing.  A value 'lambda' is added to each count and
 * to the total count.  The 'lambda' value is also used as the default count
 * for any unseen words.
 *
 * @param lambda	smoothing parameter for add-lambda smoothing
 */
class AddLambdaSmoothingCondFreqCounter[A, B](lambda: Double, delegate: CondFreqCounter[A, B]) extends DelegatingCondFreqCounter[A, B](delegate) {
  override def resultCounts() = {
    val DefaultedCondFreqCounts(delegateResultCounts, delegateTotalAddition, delegateDefaultCount) = delegate.resultCounts
    DefaultedCondFreqCounts(
      delegateResultCounts
        .mapValuesStrict {
          case DefaultedFreqCounts(c, t, d) => DefaultedFreqCounts(c.toMap.mapValuesStrict(_ + lambda), t + lambda, d + lambda)
        },
      delegateTotalAddition + lambda, delegateDefaultCount + lambda)
  }
}

//////////////////////////////////////
// Eisner-Smoothing Implementation
//////////////////////////////////////

/**
 * CondFreqCounter decorator that smoothes counts using the number of
 * single-count items to affect how much smoothing occurs; more single-count
 * items means higher likelihood of out-of-vocabulary items, and thus, more
 * smoothing should be allowed.
 *
 * This is taken from Jason Eisner's HMM homework.
 *
 * @param lambda					smoothing parameter for add-lambda smoothing
 * @param backoffFreqCounterFactory	used to compute the backoff probability
 */
class EisnerSmoothingCondFreqCounter[A, B](lambda: Double, backoffFreqCounterFactory: FreqCounterFactory[B], delegate: CondFreqCounter[A, B]) extends DelegatingCondFreqCounter[A, B](delegate) {
  private val LOG = LogFactory.getLog(classOf[EisnerSmoothingCondFreqCounter[A, B]])

  override def resultCounts() = {
    val delegateDefaultedResultCounts = delegate.resultCounts()
    val DefaultedCondFreqCounts(delegateResultCounts, delegateTotalAddition, delegateDefaultCount) = delegateDefaultedResultCounts

    val numSingleCountItems = delegateResultCounts.mapValuesStrict(_.counts.toMap.count(_._2 < 2.0))

    // Compute backoff: probability of B regardless of A
    val defaultedBackoffCounts = backoffFreqCounterFactory.get(delegateResultCounts.values.map(_.simpleCounts).foldLeft(FreqCounts[B, Double]())(_ ++ _)).resultCounts
    val DefaultedFreqCounts(backoffCounts, backoffTotalAddition, backoffDefaultCount) = defaultedBackoffCounts
    val backoffTotal = backoffCounts.toMap.values.sum + backoffTotalAddition
    val backoffDist = backoffCounts.toMap.mapValuesStrict(_ / backoffTotal)

    val smoothedResultCounts =
      delegateResultCounts.map {
        case (a, DefaultedFreqCounts(aCounts, aTotalAdd, aDefault)) =>
          val smoothedLambda = lambda * (1e-100 + numSingleCountItems.getOrElse(a, 0))
          val smoothedBackoff = FreqCounts(backoffDist.mapValuesStrict(_ * smoothedLambda))
          val smoothedCounts = smoothedBackoff ++ aCounts
          val totalAddition = 1.0
          val defaultCount = smoothedLambda / backoffTotal

          if (LOG.isDebugEnabled && Set("NN", "DT", "N", "D").contains(a.asInstanceOf[String])) {
            LOG.debug(a + ":")
            LOG.debug("    aCounts = " + aCounts.toMap.asInstanceOf[Map[String, Double]].toList.sorted.takeRight(10).map { case (k, v) => "%s -> %.2f".format(k, v) })
            LOG.debug("    smoothedLambda = " + smoothedLambda)
            LOG.debug("    smoothedBackoff = " + smoothedBackoff.toMap.asInstanceOf[Map[String, Double]].toList.sorted.takeRight(10).map { case (k, v) => "%s -> %.2f".format(k, v) })
            LOG.debug("    smoothedCounts  = " + smoothedCounts.toMap.asInstanceOf[Map[String, Double]].toList.sorted.takeRight(10).map { case (k, v) => "%s -> %.2f".format(k, v) })
            LOG.debug("    defaultCount = " + defaultCount)

            for (w <- List("the", "company").map(_.asInstanceOf[B])) {
              LOG.debug("c(%s,%s) + sing(%s) * p_back(%s) = %.2f + %.2f * %.2f = %.2f"
                .format(
                  a, w, a, w,
                  aCounts.toMap.getOrElse(w, 0.0), smoothedLambda, backoffDist(w),
                  smoothedCounts.toMap(w)))
            }
            LOG.debug("defaultCount = " + defaultCount)
          }

          (a, DefaultedFreqCounts(smoothedCounts, aTotalAdd + totalAddition, aDefault + defaultCount))
      }
    val totalAddition = 1.0
    val defaultCount = lambda / backoffTotal
    DefaultedCondFreqCounts(smoothedResultCounts, totalAddition + delegateTotalAddition, defaultCount + delegateDefaultCount)
  }
}

//////////////////////////////////////
// Factory
//////////////////////////////////////

/**
 * A factory for FreqCounter objects.  Exists so that procedures requiring
 * FreqCounters can create new ones at will.
 *
 * {{{
 *   new CondFreqCounterFactory {
 *     def get() = SimpleCondFreqCounter()
 *   }
 * }}}
 */
abstract class CondFreqCounterFactory[A, B] {
  def get(): CondFreqCounter[A, B]
  def get[N: Numeric](initial: CondFreqCounts[A, B, N]): CondFreqCounter[A, B] = get() ++= initial
}
